## PID

If you think about it, a shell script is a collection of commands added in a file on which we use several programming constructs to automate complex tasks. From what we've learned about process ID's in previous courses, we know that when a new process is created, the kernel assigns a unique ID number that can be used to track and manage the process. So, have you wondered how many process IDs get created during the execution of the shell scripts? To explore these mechanics, let's use the same chef analogy we've used in previous lectures. This time, we're going to imagine that the chef is similar to a parent shell, and the workers helping him in the kitchen are process IDs invoked by commands running in the parent shell. In shell scripting, a parent shell is the shell that launches when we start a new terminal session. The parent shell has a process ID similar to any other process. Within that terminal session, we can type and execute commands. This will generate additional process IDs, and these IDs will be called child processes and they will be associated with the parent shell. In this analogy, each instruction given by the chef occupies a resource which is one of the workers or kitchen employees completing a task. The chef assigns each person a unique identifier just like how each process has a unique ID number. The chef can view the status of each person's task just like how you can view the status of each process using commands in the terminal. The chef can also stop or restart tasks if needed, just like how you can stop or restart processes using the command line. So, in this analogy, processes invoked by the shell are like a team of people working in a restaurant kitchen. Each person is like a process and they have a specific role to play. This illustration shows a relationship between a shell and the terminal. The terminal session running a shell process is associated with a TTY. The TTY, short for Teletypewriter, is a device that allows users to interact with the system through a terminal interface. In Linux, each TTY is associated with a unique process known as a session leader or parent shell. The session leader process is responsible for managing the TTY and the associated terminal interface. While the TTY is associated with a single session leader process, it is possible for that process to spawn child processes that are also associated with the TTY. These child processes can have their own unique PIDs, but they remain part of the same TTY session as the session leader process. We already talked about TTYs in the interactive versus non-interactive shell lecture in this course. For the purpose of understanding process IDs and their relationship with the shell, let's keep in mind that a TTY is an identifier that helps link or related shell parent process with a terminal session. Therefore, each tab you have open in your terminal will have a TTY name associated to it. To find out the TTY name associated with your terminal, type the command tty as seen on the screen. So, now that we're understanding the theory behind the shell sessions in the terminal, let's analyze what happens when we invoke a script from the terminal. When we invoke a shell script, a child process is spawned. Any child processes that are spawned by the shell, such as background jobs or subprocesses, are also associated with the same TTY, but they have their own unique PIDs. To see the process IDs associated with a specific process, I generally use the ps -ef command along with a grep command to match a name of the process I'm looking. There's a whole section about grep later in this course. For now, keep in mind that grep is a command line tool for searching text. I'll dive a little deeper into managing processes at the end of this lecture as well. Here, I'm sharing my terminal and I'm going to check the TTY associated to this tab. For this, I'm typing the tty command. Observe how now I will use ps -ef grep bash to check the bash processes running on my system. This value on the left is the process ID for my bash session. Now, I'm going to open a second tab and I'll repeat the process. Observe how now a second bash process appears when I do the ps -ef grep bash. Each bash process is associated to a different TTY. Now, I'm going back to the first tab and I'll create a script name script.sh. The script will just contain a sleep command to make the script hang in there for 180 seconds while we examine the process IDs. If I run this script, however, the terminal session gets locked as the script is running a sleep command that will take 180 seconds to complete, rendering my terminal unable to receive any commands for the duration of the sleep command. Let's go to the second tab really quickly to see what's going on. If I do ps -ef and look for bash, I see that the script.sh is running. Observe how the script has its own unique process ID. Next to its process ID, we see the process ID of the parent shell. Observe how this PID is the same as the one from the bash parent shell session running on the other tab, as observed by the relationship between the TTY, the PID, and the process name. Now, I'm going to do a ps -ef to the sleep command, which is running inside the script.sh. We see that sleep is a command that is generating a process ID on its own, and we can observe the same relationship between the sleep command and its parent process, which is the script.sh script we used to invoke the sleep command. We can trace this back to the parent shell, so you can now get an idea about the relationship between each one. The TTY is associated to a bash process running in a tab. The bash process has other child processes running, and each child process can have other child processes running on its own. Now, before closing this quick demo, I want to showcase a couple of techniques to manage processes and the way they're associated to a session. I'm going to do Control plus C on the script.sh running on our first tab to terminate the scripts. Now, I'm going to run the script again passing an ampersand symbol next to the script name. Observe how this time the script is being sent to the background so I can use my terminal freely to do other commands while the script is still running. There is one problem, though. The script is still associated to this terminal session, as seen on the relationship between the process ID and the parent shell, which points to the bash process running in the TTY associated with my terminal tab. If I close this tab, the process dies as I'm going to show on the other tab I still have open. To detach a process from a TTY, we can use the null command as I'm going to demonstrate soon. By running the script with nohup and ampersand, I'm sending the script to the background and I see how by running ps -ef, the script seems to be associated with the TTY from this session as normal. After validating that the script is running, I'm going to close this tab and check on the other one to see how the script is still running. After closing the tab, I'll check ps -ef grep script.sh to observe how the script has been disassociated from a TTY. This is in essence the difference between nohup and ampersand. With the & symbol, we send a running process to the background. A process will continue to run even when the terminal where it was executed is closed, as we disassociate a process from a TTY. So far, we're getting that running scripts generate a process ID, and the commands executed inside the script generate a child process ID associated with the scripts. However, not all processes generate process IDs. There are some commands that come already prepackaged in the shell called built-in commands, and these don't generate a process ID when invoked in a traditional way. Some built-in commands can be found as binaries and, when executed by referencing their absolute path, they will generate a process ID. In the next lecture, we're going to learn more about these mechanics and the benefits it provides. I want to talk about process management in Linux to close this lecture. A very in-depth explanation is out of the scope of this course, as the topic can be explored very extensively. So, let's have a quick crash course. For running processes, we have that you can simply type the name of the program and hit enter or add it on a script just like you do with commands like LS, cat, or echo. Programs can be run using their absolute path, like the urs/bin/cat shown in the screen or from anywhere in your file system just by typing their name as long as they're added in the PATH environment variable. The dot/ notation we use to run scripts indicates that we're using a relative directory as indicated by the dot, which means current directory. For listing processes, we have that. You can view a list of all running processes on the system using various tools such as the ps command or the top command. For this course, we will use ps command along with the -ef flag to list processes. The ps command stands for Process status. The flag pass to the ps command specify that it should display information about all running processes. The -ef flag we pass in conjunction with The eflag is to include detailed information about each process. To terminate a process, use the kill command followed by the process ID that should be terminated. Kill command sends a signal to the process requesting to perform a certain action, such as terminating gracefully or terminating forcibly. The default behavior of kill is sig term, which requests the process to terminate gracefully. For example, to send the SIGTERM signal to a process with process ID 99838, you can use either of the following commands listed on the right. -SIGTERM, -15, or -TERM mean the same thing. If the process does not exit within a certain time limit, you may need to send a SIGKILL signal to forcibly terminate it. For example, to send the SIGKILL signal to a process with PID 99838, you can use either of the commands seen on the right side of the screen interchangeably, like -9, -KILL or -SIGKILL, followed by the process ID number. And, lastly, we have that for tracing we have Strace, which is a command line utility used in Linux to trace and debug system calls made by a running process showing detailed information about each call. Strace can be used to analyze system calls associated with commands and processes. During this course, we will use Strace in the following way. strace -TFP followed by a process ID for our parent shell. The -T option passed to strace is used to display timing information for each system call. The -F option to strace is used to trace child processes as well as the parent process. The -P option to strace specifies the process ID of the process to trace, in this case the parent shell.
